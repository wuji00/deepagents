# 19 - 安全机制详解

## 1. 概述

DeepAgents 实现了多层安全防护机制，包括路径验证、字符清理、权限控制和内容截断，确保代理在文件操作和命令执行时的安全性。

## 2. 路径验证机制

### 2.1 _validate_path 函数

```python
def _validate_path(
    path: str, 
    *, 
    allowed_prefixes: Sequence[str] | None = None
) -> str:
    """验证并规范化文件路径，防止目录遍历攻击。
    
    安全检查：
    1. 阻止目录遍历序列 (..)
    2. 阻止主目录扩展 (~)
    3. 阻止 Windows 绝对路径
    4. 验证允许的路径前缀
    """
    # 1. 目录遍历检查
    if ".." in path or path.startswith("~"):
        msg = f"Path traversal not allowed: {path}"
        raise ValueError(msg)

    # 2. Windows 路径检查
    if re.match(r"^[a-zA-Z]:", path):
        msg = (
            f"Windows absolute paths are not supported: {path}. "
            "Please use virtual paths starting with /"
        )
        raise ValueError(msg)

    # 3. 路径规范化
    normalized = os.path.normpath(path)
    normalized = normalized.replace("\\", "/")

    if not normalized.startswith("/"):
        normalized = f"/{normalized}"

    # 4. 前缀验证
    if allowed_prefixes is not None:
        if not any(normalized.startswith(prefix) for prefix in allowed_prefixes):
            msg = f"Path must start with one of {allowed_prefixes}: {path}"
            raise ValueError(msg)

    return normalized
```

### 2.2 防护示例

```python
# 目录遍历攻击
_validate_path("../etc/passwd")  # ValueError: Path traversal not allowed
_validate_path("../../config")   # ValueError: Path traversal not allowed

# 主目录扩展
_validate_path("~/.ssh/id_rsa")  # ValueError: Path traversal not allowed
_validate_path("~/data/file")    # ValueError: Path traversal not allowed

# Windows 路径
_validate_path("C:/Windows/System32")  # ValueError: Windows paths not supported
_validate_path("D:\\data\\file")        # ValueError: Windows paths not supported

# 合法路径
_validate_path("/data/file")     # OK: "/data/file"
_validate_path("data/file")      # OK: "/data/file"
_validate_path("/data/../file")  # OK: "/file"
```

### 2.3 前缀白名单

```python
# 限制只允许访问特定目录
_validate_path(
    "/data/projects/file.txt",
    allowed_prefixes=["/data/projects/", "/data/shared/"]
)  # OK

_validate_path(
    "/etc/passwd",
    allowed_prefixes=["/data/projects/", "/data/shared/"]
)  # ValueError: Path must start with...
```

## 3. 字符清理机制

### 3.1 sanitize_tool_call_id 函数

```python
def sanitize_tool_call_id(tool_call_id: str) -> str:
    """清理 tool_call_id，防止路径遍历和分隔符问题。
    
    替换危险字符：. / \
    用途：将 tool_call_id 用作文件名时防止目录遍历
    """
    sanitized = (
        tool_call_id
        .replace(".", "_")
        .replace("/", "_")
        .replace("\\", "_")
    )
    return sanitized
```

### 3.2 应用场景

```python
# 大结果转存时使用
tool_call_id = "call_abc123.."
sanitized_id = sanitize_tool_call_id(tool_call_id)  # "call_abc123__"
file_path = f"/large_tool_results/{sanitized_id}"

# 防止恶意 ID
tool_call_id = "../../../etc/passwd"
sanitized_id = sanitize_tool_call_id(tool_call_id)  # "_____etc_passwd"
```

## 4. 内容截断机制

### 4.1 行长度限制

```python
MAX_LINE_LENGTH = 5000  # 单行最大字符数

def format_content_with_line_numbers(content: str | list[str]) -> str:
    """格式化内容，超长行自动分割。"""
    for i, line in enumerate(lines):
        if len(line) <= MAX_LINE_LENGTH:
            result_lines.append(f"{line_num}\t{line}")
        else:
            # 分割超长行
            num_chunks = (len(line) + MAX_LINE_LENGTH - 1) // MAX_LINE_LENGTH
            for chunk_idx in range(num_chunks):
                chunk = line[chunk_idx * MAX_LINE_LENGTH:(chunk_idx + 1) * MAX_LINE_LENGTH]
                if chunk_idx == 0:
                    result_lines.append(f"{line_num}\t{chunk}")
                else:
                    result_lines.append(f"{line_num}.{chunk_idx}\t{chunk}")
```

### 4.2 Token 限制

```python
TOOL_RESULT_TOKEN_LIMIT = 20000  # 约 20000 tokens
NUM_CHARS_PER_TOKEN = 4          # 4 字符 ≈ 1 token

def truncate_if_too_long(result: list[str] | str) -> list[str] | str:
    """结果超过 token 限制时截断。"""
    if isinstance(result, list):
        total_chars = sum(len(item) for item in result)
        if total_chars > TOOL_RESULT_TOKEN_LIMIT * NUM_CHARS_PER_TOKEN:
            # 按比例截断
            ratio = TOOL_RESULT_TOKEN_LIMIT * NUM_CHARS_PER_TOKEN / total_chars
            keep_count = int(len(result) * ratio)
            return result[:keep_count] + [TRUNCATION_GUIDANCE]
        return result
    
    # 字符串截断
    if len(result) > TOOL_RESULT_TOKEN_LIMIT * NUM_CHARS_PER_TOKEN:
        max_len = TOOL_RESULT_TOKEN_LIMIT * NUM_CHARS_PER_TOKEN
        return result[:max_len] + "\n" + TRUNCATION_GUIDANCE
    return result
```

## 5. 执行权限控制

### 5.1 _supports_execution 检查

```python
def _supports_execution(backend: BackendProtocol) -> bool:
    """检查后端是否支持命令执行。"""
    # CompositeBackend 检查默认后端
    if isinstance(backend, CompositeBackend):
        return isinstance(backend.default, SandboxBackendProtocol)
    
    # 其他后端直接检查
    return isinstance(backend, SandboxBackendProtocol)
```

### 5.2 运行时检查

```python
def sync_execute(command: str, runtime: ToolRuntime) -> str:
    resolved_backend = self._get_backend(runtime)
    
    # 运行时检查
    if not _supports_execution(resolved_backend):
        return (
            "Error: Execution not available. "
            "This agent's backend does not support command execution."
        )
    
    try:
        result = resolved_backend.execute(command)
    except NotImplementedError as e:
        return f"Error: Execution not available. {e}"
    
    return result.output
```

### 5.3 工具过滤

```python
def wrap_model_call(self, request: ModelRequest, handler) -> ModelResponse:
    """根据后端能力过滤 execute 工具。"""
    has_execute_tool = any(
        (tool.name if hasattr(tool, "name") else tool.get("name")) == "execute"
        for tool in request.tools
    )
    
    backend_supports_execution = False
    if has_execute_tool:
        backend = self._get_backend(request.runtime)
        backend_supports_execution = _supports_execution(backend)
        
        # 如果不支持执行，过滤掉 execute 工具
        if not backend_supports_execution:
            filtered_tools = [
                tool for tool in request.tools
                if (tool.name if hasattr(tool, "name") else tool.get("name")) != "execute"
            ]
            request = request.override(tools=filtered_tools)
```

## 6. 文件大小限制

### 6.1 技能文件限制

```python
MAX_SKILL_FILE_SIZE = 10 * 1024 * 1024  # 10MB

def _parse_skill_metadata(content: str, ...) -> SkillMetadata | None:
    if len(content) > MAX_SKILL_FILE_SIZE:
        logger.warning("Skipping %s: content too large", skill_path)
        return None
```

### 6.2 读取限制

```python
DEFAULT_READ_LIMIT = 100  # 默认最多读取100行

# read_file 工具默认限制
def sync_read_file(
    file_path: str,
    offset: int = 0,
    limit: int = DEFAULT_READ_LIMIT,  # 默认100行
) -> str:
    result = resolved_backend.read(validated_path, offset=offset, limit=limit)
```

## 7. 字符串替换安全

### 7.1 唯一性验证

```python
def perform_string_replacement(
    content: str,
    old_string: str,
    new_string: str,
    replace_all: bool,
) -> tuple[str, int] | str:
    """执行字符串替换，带出现次数验证。"""
    occurrences = content.count(old_string)

    if occurrences == 0:
        return f"Error: String not found in file: '{old_string}'"

    if occurrences > 1 and not replace_all:
        return (
            f"Error: String '{old_string}' appears {occurrences} times in file. "
            "Use replace_all=True to replace all instances, "
            "or provide a more specific string with surrounding context."
        )

    new_content = content.replace(old_string, new_string)
    return new_content, occurrences
```

### 7.2 防止意外修改

- 要求 `old_string` 必须唯一（除非 `replace_all=True`）
- 要求先读取文件再编辑
- 精确匹配，避免模糊替换

## 8. 记忆安全指南

### 8.1 禁止存储的内容

```
<memory_guidelines>
    **When to NOT update memories:**
    - Never store API keys, access tokens, passwords, or any other credentials
    - If the user asks where to put API keys or provides an API key, 
      do NOT echo or save it.
</memory_guidelines>
```

### 8.2 实现保障

- 系统提示中明确禁止
- 通过 HumanInTheLoopMiddleware 添加人工审核
- 不自动存储任何疑似敏感信息

## 9. 安全最佳实践

### 9.1 后端选择

| 场景 | 推荐后端 | 原因 |
|------|---------|------|
| 生产环境 | SandboxBackend | 隔离执行环境 |
| 敏感数据 | StoreBackend + 访问控制 | 持久化 + 权限控制 |
| 快速测试 | StateBackend | 临时数据，无持久化风险 |

### 9.2 路径策略

```python
# 推荐：使用 allowed_prefixes 限制访问范围
middleware = FilesystemMiddleware(
    backend=backend,
    allowed_prefixes=["/workspace/", "/tmp/"]  # 只允许这些目录
)

# 避免：无限制的文件系统访问
middleware = FilesystemMiddleware(
    backend=FilesystemBackend(root_dir="/")  # 危险！可以访问整个系统
)
```

### 9.3 人工审核

```python
# 对危险操作添加人工审核
agent = create_deep_agent(
    interrupt_on={
        "edit_file": True,      # 编辑前审核
        "write_file": True,     # 写入前审核
        "execute": True,        # 执行前审核
    }
)
```

## 10. 安全审计日志

### 10.1 关键操作记录

```python
# 文件操作日志
logger.info(f"File written: {path} by tool {tool_call_id}")
logger.info(f"File edited: {path}, occurrences: {count}")

# 命令执行日志
logger.info(f"Command executed: {command}, exit_code: {exit_code}")

# 访问拒绝日志
logger.warning(f"Path access denied: {path}, reason: {reason}")
```

### 10.2 异常追踪

```python
try:
    result = backend.execute(command)
except Exception as e:
    logger.error(f"Execution failed: {command}, error: {e}")
    raise
```

## 11. 总结

DeepAgents 的安全机制覆盖多个层面：

1. **路径安全**：验证和规范化，防止目录遍历
2. **字符清理**：清理危险字符，防止注入攻击
3. **权限控制**：运行时检查后端能力
4. **内容限制**：行长度、token数、文件大小限制
5. **操作验证**：字符串替换的唯一性检查
6. **敏感信息**：系统提示明确禁止存储凭证
7. **审计日志**：关键操作记录便于追踪

这些机制共同构成了一个 Defense in Depth（纵深防御）的安全体系。
