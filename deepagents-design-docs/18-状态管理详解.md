# 18 - 状态管理详解

## 1. 概述

DeepAgents 的状态管理系统基于 LangGraph 的 state 机制，通过 TypedDict 定义状态结构，使用 Annotated 和自定义 Reducer 控制状态更新行为。

## 2. 核心概念

### 2.1 AgentState 基础

```python
from langchain.agents.middleware.types import AgentState

# AgentState 是所有中间件状态的基类
class AgentState(TypedDict):
    """Base state for agents."""
    messages: list[AnyMessage]  # 消息历史
```

### 2.2 状态扩展模式

中间件通过继承扩展状态：

```python
class FilesystemState(AgentState):
    """FilesystemMiddleware 的状态。"""
    files: Annotated[
        NotRequired[dict[str, FileData]], 
        _file_data_reducer  # 自定义 Reducer
    ]

class SkillsState(AgentState):
    """SkillsMiddleware 的状态。"""
    skills_metadata: NotRequired[
        Annotated[list[SkillMetadata], PrivateStateAttr]
    ]

class MemoryState(AgentState):
    """MemoryMiddleware 的状态。"""
    memory_contents: NotRequired[
        Annotated[dict[str, str], PrivateStateAttr]
    ]
```

## 3. FileData 数据结构

### 3.1 定义

```python
class FileData(TypedDict):
    """存储文件内容的数据结构。"""
    
    content: list[str]
    """文件的行列表。"""
    
    created_at: str
    """ISO 8601 格式的创建时间戳。"""
    
    modified_at: str
    """ISO 8601 格式的修改时间戳。"""
```

### 3.2 使用示例

```python
file_data: FileData = {
    "content": ["import os", "print('hello')", ""],
    "created_at": "2024-01-15T10:30:00",
    "modified_at": "2024-01-15T10:35:00",
}
```

## 4. Reducer 机制

### 4.1 什么是 Reducer？

Reducer 是控制状态如何合并的函数。LangGraph 使用 Annotated[Type, reducer] 语法指定。

```python
# 默认行为：后者覆盖前者
state_field: int

# 使用自定义 Reducer
state_field: Annotated[int, my_reducer]
```

### 4.2 _file_data_reducer 详解

```python
def _file_data_reducer(
    left: dict[str, FileData] | None, 
    right: dict[str, FileData | None]
) -> dict[str, FileData]:
    """合并文件更新，支持删除操作。
    
    设计目标：
    - 支持增量更新
    - 支持文件删除（通过 None 标记）
    - 处理初始状态为 None 的情况
    """
    # 初始状态处理
    if left is None:
        # 过滤掉值为 None 的项（删除标记）
        return {k: v for k, v in right.items() if v is not None}

    # 复制现有状态
    result = {**left}
    
    # 应用更新
    for key, value in right.items():
        if value is None:
            # None 表示删除
            result.pop(key, None)
        else:
            # 非 None 表示添加或更新
            result[key] = value
    
    return result
```

### 4.3 Reducer 工作流程

```
初始状态: left = None
更新: right = {"/file.txt": FileData(...)}
结果: {"/file.txt": FileData(...)}

---

当前状态: left = {"/a.txt": data1, "/b.txt": data2}
更新: right = {"/b.txt": None}  # 删除 b.txt
结果: {"/a.txt": data1}

---

当前状态: left = {"/a.txt": data1}
更新: right = {"/a.txt": data1_updated, "/c.txt": data3}
结果: {"/a.txt": data1_updated, "/c.txt": data3}
```

## 5. PrivateStateAttr - 私有状态

### 5.1 概念

```python
from langchain.agents.middleware.types import PrivateStateAttr

class SkillsState(AgentState):
    skills_metadata: NotRequired[
        Annotated[list[SkillMetadata], PrivateStateAttr]
    ]
```

`PrivateStateAttr` 标记的状态：
- **不传播**给父代理
- **不参与**子代理调用
- **仅用于**当前代理内部

### 5.2 使用场景

| 中间件 | 私有状态 | 原因 |
|--------|---------|------|
| SkillsMiddleware | skills_metadata | 技能元数据是代理私有的 |
| MemoryMiddleware | memory_contents | 记忆内容不应污染父代理 |
| SubAgentMiddleware | - | 子代理规范是共享的 |

### 5.3 传播控制

```python
# 子代理调用时的状态过滤
# 1. 标记为 PrivateStateAttr 的字段被过滤
# 2. 只传递非私有状态给子代理

parent_state = {
    "messages": [...],
    "skills_metadata": [...],  # PrivateStateAttr，被过滤
    "memory_contents": {...},  # PrivateStateAttr，被过滤
}

child_state = {
    "messages": [...],  # 只传递非私有字段
}
```

## 6. State Schema 注册

### 6.1 中间件状态注册

```python
class FilesystemMiddleware(AgentMiddleware):
    state_schema = FilesystemState  # 注册状态模式

class SkillsMiddleware(AgentMiddleware):
    state_schema = SkillsState
```

### 6.2 状态合并

LangGraph 自动合并多个中间件的状态：

```python
# 多个中间件的状态
FilesystemState: {messages, files}
SkillsState: {messages, skills_metadata}
MemoryState: {messages, memory_contents}

# 合并后的状态
MergedState: {
    messages,        # 共享字段
    files,           # FilesystemMiddleware
    skills_metadata, # SkillsMiddleware  
    memory_contents  # MemoryMiddleware
}
```

## 7. 状态更新模式

### 7.1 直接返回值

```python
def before_agent(self, state, runtime, config):
    """返回状态更新字典。"""
    return {"memory_contents": {"path": "content"}}
```

### 7.2 使用 Command

```python
def _create_write_file_tool(self):
    def sync_write_file(...):
        res = resolved_backend.write(path, content)
        if res.files_update is not None:
            return Command(
                update={
                    "files": res.files_update,  # 状态更新
                    "messages": [ToolMessage(...)],  # 消息更新
                }
            )
```

### 7.3 使用 Overwrite

```python
from langgraph.types import Overwrite

# 完全替换字段值
return {"messages": Overwrite(new_messages)}
```

## 8. NotRequired 的使用

### 8.1 可选字段标记

```python
from typing import NotRequired

class FilesystemState(AgentState):
    files: Annotated[
        NotRequired[dict[str, FileData]],  # 可选字段
        _file_data_reducer
    ]
```

### 8.2 作用

- 允许状态初始化时不包含该字段
- 第一次更新时自动创建
- 减少初始状态的复杂性

## 9. 状态管理最佳实践

### 9.1 设计原则

1. **最小化状态**：只存储必要的数据
2. **使用 PrivateStateAttr**：避免状态污染
3. **自定义 Reducer**：精确控制合并行为
4. **类型安全**：使用 TypedDict 和类型注解

### 9.2 常见模式

```python
# 模式1：状态检查
if "files" in state:
    # 状态已存在
    files = state["files"]
else:
    # 初始化状态
    files = {}

# 模式2：默认值
files = state.get("files", {})

# 模式3：使用 NotRequired + Reducer
# 让 LangGraph 自动处理初始化和合并
```

## 10. 状态调试

### 10.1 查看当前状态

```python
# 在工具中访问状态
def tool_func(runtime: ToolRuntime):
    state = runtime.state
    print(f"Current files: {state.get('files', {})}")
```

### 10.2 状态变更追踪

```python
# 在 Reducer 中添加日志
def _file_data_reducer(left, right):
    logger.debug(f"Reducer input: left={left}, right={right}")
    result = ...
    logger.debug(f"Reducer output: {result}")
    return result
```

## 11. 总结

DeepAgents 的状态管理系统：

1. **TypedDict 定义**：类型安全的状态结构
2. **Annotated + Reducer**：灵活的合并控制
3. **PrivateStateAttr**：隔离代理私有数据
4. **NotRequired**：简化初始状态
5. **Command/Overwrite**：多样的更新方式

这种设计平衡了灵活性和类型安全，支持复杂的多代理场景。
