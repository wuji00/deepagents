# 17 - 工具实现详解

## 1. 概述

FilesystemMiddleware 提供了7个核心文件操作工具，每个工具都实现了同步和异步版本。这些工具通过 `StructuredTool.from_function` 创建，支持类型注解和自动生成参数描述。

## 2. 工具清单

| 工具名 | 功能 | 是否支持大结果转存 |
|--------|------|-------------------|
| `ls` | 列出目录文件 | 是 |
| `read_file` | 读取文件内容 | 否（内置截断） |
| `write_file` | 创建/覆盖文件 | 否 |
| `edit_file` | 编辑文件内容 | 否 |
| `glob` | Glob模式搜索 | 是 |
| `grep` | 内容搜索 | 是 |
| `execute` | 执行Shell命令 | 是 |

## 3. 工具创建模式

### 3.1 统一创建模式

所有工具遵循相同的创建模式：

```python
def _create_xx_tool(self) -> BaseTool:
    """Create the xx tool."""
    tool_description = self._custom_tool_descriptions.get("xx") or XX_TOOL_DESCRIPTION

    def sync_xx(..., runtime: ToolRuntime) -> str:
        """Synchronous wrapper."""
        resolved_backend = self._get_backend(runtime)
        # ... 实现
        return result

    async def async_xx(..., runtime: ToolRuntime) -> str:
        """Asynchronous wrapper."""
        resolved_backend = self._get_backend(runtime)
        # ... 实现
        return result

    return StructuredTool.from_function(
        name="xx",
        description=tool_description,
        func=sync_xx,
        coroutine=async_xx,
    )
```

### 3.2 ToolRuntime 注入

```python
def sync_ls(
    runtime: ToolRuntime[None, FilesystemState],  # 运行时上下文
    path: Annotated[str, "描述"],  # 用户参数
) -> str:
```

`ToolRuntime` 提供：
- `runtime.state`: 当前代理状态
- `runtime.context`: 上下文变量
- `runtime.tool_call_id`: 当前工具调用ID

## 4. 各工具详解

### 4.1 ls - 列出目录

```python
def _create_ls_tool(self) -> BaseTool:
    def sync_ls(
        runtime: ToolRuntime[None, FilesystemState],
        path: Annotated[str, "Absolute path to the directory..."],
    ) -> str:
        resolved_backend = self._get_backend(runtime)
        try:
            validated_path = _validate_path(path)  # 路径验证
        except ValueError as e:
            return f"Error: {e}"
        
        infos = resolved_backend.ls_info(validated_path)
        paths = [fi.get("path", "") for fi in infos]
        result = truncate_if_too_long(paths)  # 结果截断
        return str(result)
```

**特点：**
- 返回绝对路径列表
- 结果按修改时间排序
- 自动截断大结果

### 4.2 read_file - 读取文件

```python
def _create_read_file_tool(self) -> BaseTool:
    def sync_read_file(
        file_path: Annotated[str, "Absolute path..."],
        runtime: ToolRuntime[None, FilesystemState],
        offset: Annotated[int, "Line number to start..."] = 0,
        limit: Annotated[int, "Maximum number of lines..."] = 100,
    ) -> str:
        resolved_backend = self._get_backend(runtime)
        try:
            validated_path = _validate_path(file_path)
        except ValueError as e:
            return f"Error: {e}"
        
        result = resolved_backend.read(validated_path, offset=offset, limit=limit)
        
        lines = result.splitlines(keepends=True)
        if len(lines) > limit:
            lines = lines[:limit]
            result = "".join(lines)
        
        # Token 限制检查
        if token_limit and len(result) >= NUM_CHARS_PER_TOKEN * token_limit:
            truncation_msg = READ_FILE_TRUNCATION_MSG.format(file_path=validated_path)
            max_content_length = NUM_CHARS_PER_TOKEN * token_limit - len(truncation_msg)
            result = result[:max_content_length] + truncation_msg
        
        return result
```

**特点：**
- 支持分页读取（offset + limit）
- 内置token限制检查
- 自动截断超长行

### 4.3 write_file - 写入文件

```python
def _create_write_file_tool(self) -> BaseTool:
    def sync_write_file(
        file_path: Annotated[str, "Absolute path..."],
        content: Annotated[str, "The text content..."],
        runtime: ToolRuntime[None, FilesystemState],
    ) -> Command | str:
        resolved_backend = self._get_backend(runtime)
        try:
            validated_path = _validate_path(file_path)
        except ValueError as e:
            return f"Error: {e}"
        
        res: WriteResult = resolved_backend.write(validated_path, content)
        if res.error:
            return res.error
        
        # 如果后端返回状态更新，包装为Command
        if res.files_update is not None:
            return Command(
                update={
                    "files": res.files_update,
                    "messages": [
                        ToolMessage(
                            content=f"Updated file {res.path}",
                            tool_call_id=runtime.tool_call_id,
                        )
                    ],
                }
            )
        return f"Updated file {res.path}"
```

**特点：**
- 返回 `Command` 以更新状态
- 支持后端返回文件更新

### 4.4 edit_file - 编辑文件

```python
def _create_edit_file_tool(self) -> BaseTool:
    def sync_edit_file(
        file_path: Annotated[str, "Absolute path..."],
        old_string: Annotated[str, "The exact text to find..."],
        new_string: Annotated[str, "The text to replace..."],
        runtime: ToolRuntime[None, FilesystemState],
        *,
        replace_all: Annotated[bool, "If True, replace all..."] = False,
    ) -> Command | str:
        resolved_backend = self._get_backend(runtime)
        try:
            validated_path = _validate_path(file_path)
        except ValueError as e:
            return f"Error: {e}"
        
        res: EditResult = resolved_backend.edit(
            validated_path, old_string, new_string, replace_all=replace_all
        )
        if res.error:
            return res.error
        
        if res.files_update is not None:
            return Command(
                update={
                    "files": res.files_update,
                    "messages": [
                        ToolMessage(
                            content=f"Successfully replaced {res.occurrences} instance(s)...",
                            tool_call_id=runtime.tool_call_id,
                        )
                    ],
                }
            )
        return f"Successfully replaced {res.occurrences} instance(s)..."
```

**特点：**
- 支持 `replace_all` 参数
- 返回替换次数统计

### 4.5 glob - 文件搜索

```python
def _create_glob_tool(self) -> BaseTool:
    def sync_glob(
        pattern: Annotated[str, "Glob pattern..."],
        runtime: ToolRuntime[None, FilesystemState],
        path: Annotated[str, "Base directory..."] = "/",
    ) -> str:
        resolved_backend = self._get_backend(runtime)
        infos = resolved_backend.glob_info(pattern, path=path)
        paths = [fi.get("path", "") for fi in infos]
        result = truncate_if_too_long(paths)
        return str(result)
```

**特点：**
- 支持 `**` 递归匹配
- 支持 `{a,b}` 扩展

### 4.6 grep - 内容搜索

```python
def _create_grep_tool(self) -> BaseTool:
    def sync_grep(
        pattern: Annotated[str, "Text pattern..."],
        runtime: ToolRuntime[None, FilesystemState],
        path: Annotated[str | None, "Directory to search..."] = None,
        glob: Annotated[str | None, "Glob pattern to filter..."] = None,
        output_mode: Annotated[
            Literal["files_with_matches", "content", "count"],
            "Output format..."
        ] = "files_with_matches",
    ) -> str:
        resolved_backend = self._get_backend(runtime)
        raw = resolved_backend.grep_raw(pattern, path=path, glob=glob)
        
        if isinstance(raw, str):  # 错误消息
            return raw
        
        formatted = format_grep_matches(raw, output_mode)
        return truncate_if_too_long(formatted)
```

**特点：**
- 三种输出模式
- 支持文件名过滤

### 4.7 execute - 命令执行

```python
def _create_execute_tool(self) -> BaseTool:
    def sync_execute(
        command: Annotated[str, "Shell command..."],
        runtime: ToolRuntime[None, FilesystemState],
    ) -> str:
        resolved_backend = self._get_backend(runtime)
        
        # 运行时检查后端支持
        if not _supports_execution(resolved_backend):
            return "Error: Execution not available..."
        
        try:
            result = resolved_backend.execute(command)
        except NotImplementedError as e:
            return f"Error: Execution not available. {e}"
        
        # 格式化输出
        parts = [result.output]
        if result.exit_code is not None:
            status = "succeeded" if result.exit_code == 0 else "failed"
            parts.append(f"\n[Command {status} with exit code {result.exit_code}]")
        if result.truncated:
            parts.append("\n[Output was truncated due to size limits]")
        
        return "".join(parts)
```

**特点：**
- 运行时检查执行支持
- 格式化命令输出

## 5. 大结果转存机制

### 5.1 转存触发条件

```python
TOOLS_EXCLUDED_FROM_EVICTION = (
    "ls", "glob", "grep", "read_file", "edit_file", "write_file",
)

# 在 wrap_tool_call 中检查
if self._tool_token_limit_before_evict is None or \
   request.tool_call["name"] in TOOLS_EXCLUDED_FROM_EVICTION:
    return handler(request)
```

### 5.2 转存流程

```python
def _process_large_message(
    self,
    message: ToolMessage,
    resolved_backend: BackendProtocol,
) -> tuple[ToolMessage, dict[str, FileData] | None]:
    """将大工具结果转存到文件系统。"""
    
    # 1. 检查是否超过阈值
    if len(content_str) <= NUM_CHARS_PER_TOKEN * self._tool_token_limit_before_evict:
        return message, None
    
    # 2. 写入文件系统
    sanitized_id = sanitize_tool_call_id(message.tool_call_id)
    file_path = f"/large_tool_results/{sanitized_id}"
    result = resolved_backend.write(file_path, content_str)
    
    # 3. 创建预览
    content_sample = _create_content_preview(content_str)
    replacement_text = TOO_LARGE_TOOL_MSG.format(
        tool_call_id=message.tool_call_id,
        file_path=file_path,
        content_sample=content_sample,
    )
    
    # 4. 返回替换消息
    processed_message = ToolMessage(
        content=replacement_text,
        tool_call_id=message.tool_call_id,
        name=message.name,
    )
    return processed_message, result.files_update
```

### 5.3 预览生成

```python
def _create_content_preview(
    content_str: str, 
    *, 
    head_lines: int = 5, 
    tail_lines: int = 5
) -> str:
    """创建内容预览（头部 + 省略标记 + 尾部）。"""
    lines = content_str.splitlines()
    
    if len(lines) <= head_lines + tail_lines:
        # 小文件：显示全部
        preview_lines = [line[:1000] for line in lines]
        return format_content_with_line_numbers(preview_lines, start_line=1)
    
    # 大文件：显示头部和尾部
    head = [line[:1000] for line in lines[:head_lines]]
    tail = [line[:1000] for line in lines[-tail_lines:]]
    
    head_sample = format_content_with_line_numbers(head, start_line=1)
    truncation_notice = f"\n... [{len(lines) - head_lines - tail_lines} lines truncated] ...\n"
    tail_sample = format_content_with_line_numbers(tail, start_line=len(lines) - tail_lines + 1)
    
    return head_sample + truncation_notice + tail_sample
```

## 6. 工具描述设计

### 6.1 详细的使用说明

每个工具描述包含：
- 功能说明
- 使用示例
- 最佳实践
- 常见错误

**read_file 示例：**
```python
READ_FILE_TOOL_DESCRIPTION = """Reads a file from the filesystem.

Usage:
- By default, it reads up to 100 lines starting from the beginning
- **IMPORTANT for large files**: Use pagination with offset and limit
  - First scan: read_file(path, limit=100)
  - Read more: read_file(path, offset=100, limit=200)
- Results are returned using cat -n format
- Lines longer than 5,000 characters will be split
- You should ALWAYS make sure a file has been read before editing it."""
```

### 6.2 execute 工具的特殊说明

```python
EXECUTE_TOOL_DESCRIPTION = """Executes a shell command in an isolated sandbox environment.

Usage notes:
  - Commands run in an isolated sandbox environment
  - VERY IMPORTANT: You MUST avoid using search commands like find and grep
  - Try to maintain your current working directory...

Examples:
  Good examples:
    - execute(command="pytest /foo/bar/tests")
  Bad examples (avoid these):
    - execute(command="cat file.txt")  # Use read_file instead
"""
```

## 7. 同步/异步统一处理

所有工具都实现了双版本：

```python
def sync_xx(...) -> str:
    """同步版本使用 backend.xx()"""
    result = resolved_backend.xx(...)
    return result

async def async_xx(...) -> str:
    """异步版本使用 backend.axx()"""
    result = await resolved_backend.axx(...)
    return result

return StructuredTool.from_function(
    name="xx",
    func=sync_xx,
    coroutine=async_xx,  # LangChain 自动选择
)
```

## 8. 总结

FilesystemMiddleware 的工具实现体现了以下设计原则：

1. **一致性**：所有工具遵循相同的创建模式
2. **类型安全**：使用 Annotated 提供参数描述
3. **双模式支持**：同步/异步自动适配
4. **大结果处理**：自动转存防止上下文溢出
5. **详细文档**：每个工具都有完整的使用说明
6. **状态集成**：通过 Command 返回状态更新
